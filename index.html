<!DOCTYPE html>
<html lang="en">

<head>
  <title>Advanced Functions</title>
</head>

<body>
  <h1>Advanced Functions</h1>
  <p>Please load this file in VSCode and Chrome, and open the Console in Chrome Dev Tools.</p>
  <p>Work through the challenges found inside the script tag in this document,
    until the Console reports all tests passing.</p>

  <script>
    // In CHALLENGES 1-8 you will flesh out some functions.

    // To do this, translate each 🧠 set of instructions into a working function.
    // ❗ Functions are already scaffolded as arrow functions.
    // ❗ Watch the Guided Project to learn proper debugging technique.

    // 👉 CHALLENGE 1
    // 🧠 The function processSingleLearner takes a learner object as its argument, and returns it after some modifications.
    // 🧠 If the learner has a "lovesJS" property set to 0, we need to set it to false.
    // 🧠 If the learner has a "lovesJS" property set to 1, we need to set it to true.
    // 🤔 The reason is that in some databases, Booleans true and false are actually stored as 1 and 0 respectively.
    // 🤔 But real Booleans are easier to work with, and that is why we might need a function like this!
    // 🧠 Examples of usage:
    // processSingleLearner({ name: "Elisabeth", lovesJS: 1 }) // should return { name: "Elisabeth", lovesJS: true }
    // processSingleLearner({ name: "Pete", age: 23, lovesJS: 0 }) // should return { name: "Pete", age: 23, lovesJS: false }
    // Step 1: Pass the obj
    // Step 2: Add conditional logic
      // a: if learner.lovesJS == 0 : set learner.lovesJS = false;
      // b: if learner.lovesJS == 1 : set learner.lovesJS = true;
    // Step 3: return learner
    const processSingleLearner = (learner) => {
        if (learner.lovesJS === 0) {
          learner.lovesJS = false;
        } else if (learner.lovesJS === 1) {
          learner.lovesJS = true;
         }
         return learner; 
        }


    // 👉 CHALLENGE 2
    // 🧠 The function processLearnerLoop takes an array of learner objects as its argument, and returns it after some modifications.
    // 🧠 For each learner, if the learner has a "lovesJS" property set to 0, we need to set it to false.
    // 🧠 For each learner, if the learner has a "lovesJS" property set to 1, we need to set it to true.
    // 🧠 Examples of usage:
    // processSingleLearner([{ name: "Elisabeth", lovesJS: 1 },{ name: "Pete", age: 23, lovesJS: 0 }]) - note: you can use this line to test in the console
    //   should return [{ name: "Elisabeth", lovesJS: true },{ name: "Pete", age: 23, lovesJS: false }]
    // ❗ Notes:
    // 🧠 There are many approaches to this problem: using a loop, using forEach, using map...
    // 🧠 Solve this challenge using a for/in loop or a for loop.
    // Step 1: Pass the array - note: it should be plural
    // Step 2: Initiate result arr (actually you don't need this)
    // Step 3: Create for/in loop to loop over learner array - note: at each learner we will be making a modification
    // Step 4: declare a new var for learner = learner[idx] to get the current learner object (not the index position #)
    // Step 5: Add conditional logic
        // a: if learner.lovesJS === 0 : learner.lovresJS = false
        // b: else if
        // c: learner.lovesJS === 1: learner.lovesJS = true
    // Step 6: modify the learner object with adding push to result and passing in learner
    // Step 7: Don't forget to return the leearners array (you don't need a results array)
    const processLearnersLoop = (learners) => {
     // let result = [];
      for (let idx in learners) {
       const learner = learners[idx];
       //console.log(learner)
        if(learner.lovesJS === 0) {
            learner.lovesJS = false;
        } else if (learner.lovesJS === 1) {
          learner.lovesJS = true;
        }
        //result.push(learner);
      }
      //return result; 
      return learners
    }

    // Gab's Alt Solution
    // const processLearnersLoop = (learners) => {
    //   for (let index in learners) {
    //     const learner = learners[index]
    //     processSingleLearner(learner) // grabbing the function from above instead of reapeating code
    //   }
    //   return learners
    // }


    // 👉 CHALLENGE 3
    // 🧠 The function processLearnerForEach takes an array of learner objects as its argument, and returns it after some modifications.
    // 🧠 It is an alternate implementation of the function processLearnersLoop above.
    // ❗ Notes:
    // 🧠 Solve this challenge using the forEach method of the learners array.
    // 🧠 Use arrow functions whenever possible.
    // Step 1: Pass learner obj argument
    // Step 2: Assign an empty results array - Note! don't need because we are modifying the array not returning a new array
    // Step 3: loop through obj with forEach
    // Step 4: Create a copy of the learner object with spread operator ...
      // note: this is so you don't mutate the original object
    // Step 5: Add conditional logic: (see above)
    // Wow! I was really close on that one!!
    // const processLearnerForEach = (learners) => {
    //   //let result = []
    //   learners.forEach(learner => {
    //     let learnerCopy = {... learner}; 
    //     if(learner.lovesJS === 0) {
    //         learner.lovesJS = false;
    //     } else if (learner.lovesJS === 1) {
    //       learner.lovesJS = true;
    //     }
    //     //result.push(learner)
    //   })
    //   //return result; 
    //   return learners
    // }

   // Gab's Solution
   const processLearnerForEach = (learners) => {
    learners.forEach(learner => {
      processSingleLearner(learner)
    })
    return learners
   }

    // 👉 CHALLENGE 4
    // 🧠 The function processLearnerMap takes an array of learner objects as its argument, and returns a new array.
    // 🧠 It is an alternate implementation of the function processLearnersLoop above.
    // ❗ Notes:
    // 🧠 Solve this challenge using the map method of the learners array.
    // 🧠 Use arrow functions.
    // Step 1: Pass learners obj arr to function
    // Step 2: Assign a var to learners.map 
    // Step 3: Pass in a call back function: learner into map method
    // Step 4: Create a copy of the learner object
    // Step 5: Add conditional logic as above
      // Note: be sure to compare the new var copy learnerCopy
    // Step 5: Return the modified copy
    // Step 6: Return learnerProcessed
    const processLearnerMap = (learners) => {
       let learnerProcessed = learners.map( learner => {
        const learnerCopy = {... learner};

        if(learnerCopy.lovesJS === 0) {
          learnerCopy.lovesJS = false;
        } else if (learnerCopy.lovesJS === 1) {
          learnerCopy.lovesJS = true;
        }
        return learnerCopy;
       })
       return learnerProcessed;
    }

    // Gab's Solution
    // const processLearnerMap = (learners) => {
    //   const result = learners.map(processSingleLearner)
    //   return result
    // }

    // Gab's longer Solution
    // const processLearnerMap = (learners) => {
    //   const result = learners.map(learner => {
    //     if(learner.lovesJS === 0) {
    //       learner.lovesJS = false
    //     } else if (learner.lovesJS === 1) {
    //       learner.lovesJS = true
    //     }
    //     return learner
    //   })
    //   return result
    // }

    // 👉 CHALLENGE 5
    // 🧠 The function getJavaScriptLoversForEach takes an array of learner objects and returns an array or a string.
    // 🧠 The returned array must contain only the learners who love JavaScript.
    // 🧠 However, if nobody loves JavaScript the function returns the string "no JS lovers here!".
    // 🧠 Another complication is that the lovesJS prop on the learner could be a Boolean (false/true) or a number (0/1).
    // ❗ Notes:
    // 🧠 Solve this challenge using the forEach method of the learners array.
    // 🧠 You will need to declare a result array into which you push learners from inside your forEach loop.
    // Step 1: Pass the learners 
    // Step 2: Assign result array to hold our JS lovers
    // Step 3: Iterate over learners with forEach method 
      // note: we are looping over the current learner
    // Step 4: Add conditional logic
        // a: if learners that love JS is true 
    // Step 5: push that learner into your result array (ie add push method to your result array)
    // Step 6: Add another if statement:
        // a: if the length of the result does NOT exist
        // b: return the string 'no JS lovers here!'
    const getJavaScriptLoversForEach = (learners) => {
        let result = [];
        
        learners.forEach(learner => {
          if(learner.lovesJS) {
            result.push(learner)
          } // note: we must loop through the learners array first to detirmine if there are any learners that love JS to put into the result array 
        });
        if (!result.length) {
          return 'no JS lovers here!' // if there are no results pushed into the array the length of the results array will be zero, that's why this if statement goes 2nd
        }
        
        return result
    }

    // 👉 CHALLENGE 6
    // 🧠 The function getJavaScriptLoversFilter takes an array of learner objects and returns an array or a string.
    // 🧠 It should work exactly the same as the getJavaScriptLoversForEach function above.
    // ❗ Notes:
    // 🧠 Solve this challenge using the filter method of the learners array.
    // Step 1: Pass the learner obj arr
    // Step 2: Declare a var for the filtered learners, Assign to to the learners with a filter method on it
    // Step 3: Pass a learner function into the filter method, aka callback which will be applied to each individual learner
      // Note: This function should return ture for elements you want to keep (ie learners that love JS), and false for those you want to discard
    // Step 4: Add the conditinal logic to the function as a return (not if)
      // a: if learner lovesJS return ture
      // b: (else) return false
      // c: if there is NO filtered learers 
      // d: return string 'no JS lovers here@'
    // Step 5: Finally return filtered learners
    const getJavaScriptLoversFilter = (learners) => {
      let filteredLearners = learners.filter(learner => {
        if(learner.lovesJS) {
          return true
        }
          return false;
    })
      if (!filteredLearners.length) {
        return 'no JS lovers here!'
      } 
      return filteredLearners; // this line has no chance of running
  }

    // 👉 CHALLENGE 7
    // 🧠 The function sumOddInts takes an array of integers as its argument and returns an array with two elements.
    // 🧠 The first element is a number which is the sum of the odd integers in the original array.
    // 🧠 The second element is an array containing only the odd numbers from the original array, in the same order.
    // 🧠 Examples of usage:
    // sumOddInts([0, 1, 2, 3, 4, 5]) // should return [9, [1, 3, 5]]
    // sumOddInts([2, 5, 1, 4, 0]) // should return [6, [5, 1]]
    // sumOddInts([2, 6]) // should return [0, []]
    // sumOddInts([]) // should return [0, []]
    // ❗ Notes:
    // 🧠 This could be solved by using filter to make an array of odd integers, and then using forEach to add them up.
    // 🧠 Or you could opt for solving everything with a single forEach which is the recommended approach (saves a loop).
    // Step 1: Pass in the array argument
    // Step 2: Assign a result array containing 2 elements for results
      // note: the 2 elements should be a number beginning at 0, and an empty array for the odd numbers
    // Step 3: Use forEach loop to loop through arr
    // Step 4: Apply conditional logic:
        // a: if num is odd: 
        // b: add it to te sum (first element of result) 
        // c: also push it to the second element of the result array
    // Step 5: Return result array, after the loop
    // const sumOddInts = (arr) => {
    //   let result = [0, []];
    //   arr.forEach(num => {
    //     if (num % 2 !== 0) {
    //       result[0] += num;
    //       result[1].push(num);
    //     }
    //   })
    //   return result;
    // }

    // Gab's Solution
    const sumOddInts = (ints) => { // Step 1: pass a var for array of odd integers
      let sum = 0 // Step 2a: declare a var for the first element which is a sum of the odd integers
      let odds = [] // Step 2b: declare an empty array for second element, the odd integers
      ints.forEach(int => { // Step 3: loop over ints array with forEach 3b: pass in call back for each of the integers (give it a single name)
        if (int % 2 !==0) { // Step 4: add logic: if integer is not even
          //console.log('it is odd')
          odds.push(int) // Step 4b: push it into the odds array
          sum += int // Step 4c: add the integer to the sum count
        }
      })
     return [sum, odds] // Step 5: Finally return sum count, and odds array
    }
// test in chrome: sumOddInts ([0, 1, 2, 3, 4, 5])

    // 👉 CHALLENGE 8
    // 🧠 The function checkInts takes any number of arguments, but each argument is an integer.
    // 🧠 The return value is a new array of strings, its length equal to the number of arguments passed.
    // 🧠 Each string is "even" if the integer was even, or "odd" if it was odd.
    // 🧠 If no arguments are passed however, return the string "pass some arguments, yo!". (edge case)
    // 🧠 Examples of usage:
    // checkInts(0, 1, 2, 3, 4, 5) // should return ["even", "odd","even", "odd","even", "odd"]
    // checkInts(2, 5, 1, 4, 0) // should return ["even", "odd", "odd", "even", "even"]
    // checkInts(2, 6) // should return ["even", "even"]
    // ❗ Notes:
    // 🧠 Solve this problem using rest parameters and map.
    // Step 1: Pass in any number of integer arguments using rest syntax
    // Step 2: Check for no arguments: 
        // a: if there are no integers: (remember to check the length of the integer and not just the integer)
        // b: return 'pass some arguments, yo!'
    // Step 3: Declare oddEvenInts, assign to integers.map
    // Step 4: Pass in a function that isolates the integer & add conditional logic:
        // a: if the integer is odd: return the string 'odd'
        // b: else return the string 'even'
    // Step 5: Finally, after the loop, return oddEvenInts array or whatever that is called
    // const checkInts = (...integers) => {
    //   if (integers.length === 0){
    //     return 'pass some arguments, yo!';
    //   }
    //   let oddEvenInts = integers.map(integer => {
    //     if (integer % 2 !== 0) {
    //       return 'odd';
    //     } else {
    //       return 'even';
    //     }  
    //   })
    //   return oddEvenInts; 
    // }

    // Gab's Solution
    const checkInts = (...nums) => {
      if (!nums.length) {
        return 'pass some arguments, yo!';
      }
      return nums.map(num => {
        if (num % 2 === 0) {
          return 'even'
        }
        return 'odd'
      })
    }
// Note .map() & .filter() return new arrays
// forEach() is a pure loop that does not give back new array
    // 🧪 TESTS, do not work below this line
    // 🧪 TESTS, do not work below this line
    // 🧪 TESTS, do not work below this line
    runTests('CHALLENGE 1 - processSingleLearner', processSingleLearner, [
      [[{ lovesJS: 1 }], { lovesJS: true }],
      [[{ lovesJS: 0 }], { lovesJS: false }],
      [[{ name: "Elisabeth", lovesJS: 1 }], { name: "Elisabeth", lovesJS: true }],
      [[{ name: "Pete", age: 23, lovesJS: 0 }], { name: "Pete", age: 23, lovesJS: false }],
    ])
    const processLearnersTest = [
      [[[{ name: "Elisabeth", lovesJS: 1 }, { name: "Pete", age: 23, lovesJS: 0 }]], [{ name: "Elisabeth", lovesJS: true }, { name: "Pete", age: 23, lovesJS: false }]],
      [[[{ lovesJS: 1 }, { lovesJS: 0 }, { lovesJS: 1 }, { lovesJS: 0 }]], [{ lovesJS: true }, { lovesJS: false }, { lovesJS: true }, { lovesJS: false }]],
    ]
    runTests('CHALLENGE 2 - processLearnersLoop', processLearnersLoop, processLearnersTest)
    runTests('CHALLENGE 3 - processLearnerForEach', processLearnerForEach, processLearnersTest)
    runTests('CHALLENGE 4 - processLearnerMap', processLearnerMap, processLearnersTest)
    const getJavaScriptLoversTest = [
      [[[{ name: "Elisabeth", lovesJS: 1 }, { name: "Pete", age: 23, lovesJS: 0 }]], [{ name: "Elisabeth", lovesJS: 1 }]],
      [[[{ name: "Elisabeth", lovesJS: false }, { name: "Pete", age: 23, lovesJS: true }]], [{ name: "Pete", age: 23, lovesJS: true }]],
      [[[{ lovesJS: 1 }, { lovesJS: 0 }, { lovesJS: true }, { lovesJS: false }]], [{ lovesJS: 1 }, { lovesJS: true }]],
      [[[{ lovesJS: false }, { lovesJS: 0 }, { lovesJS: false }]], "no JS lovers here!"],
    ]
    runTests('CHALLENGE 5 - getJavaScriptLoversForEach', getJavaScriptLoversForEach, getJavaScriptLoversTest)
    runTests('CHALLENGE 6 - getJavaScriptLoversFilter', getJavaScriptLoversFilter, getJavaScriptLoversTest)
    runTests('CHALLENGE 7 - sumOddInts', sumOddInts, [
      [[[0, 1, 2, 3, 4, 5]], [9, [1, 3, 5]]],
      [[[2, 5, 1, 4, 0]], [6, [5, 1]]],
      [[[2, 6]], [0, []]],
      [[[]], [0, []]],
    ])
    runTests('CHALLENGE 8 - checkInts', checkInts, [
      [[0, 1, 2, 3, 4, 5], ["even", "odd", "even", "odd", "even", "odd"]],
      [[2, 5, 1, 4, 0], ["even", "odd", "odd", "even", "even"]],
      [[2, 6], ["even", "even"]],
      [[3, 5], ["odd", "odd"]],
      [[], "pass some arguments, yo!"],
    ])
    function runTests(testName, func, tests) {
      let results = []
      tests.forEach(test => {
        const argsList = test[0]
        const expected = JSON.stringify(test[1])
        const actual = JSON.stringify(func.apply(null, JSON.parse(JSON.stringify(argsList))))
        results.push([argsList, expected, actual])
      })
      console.log('\n' + testName)
      if (results.every(result => result[1] === result[2])) console.log('\t✅ All tests pass')
      else results.forEach((result, idx) => {
        if (result[1] === result[2]) console.log(`\t✅ Test ${idx + 1} passes`)
        else console.log(`\t❌ Test ${idx + 1} fails: ${func.name}(${result[0]
          .map(JSON.stringify)}) should return ${result[1]} but returns ${result[2]}`)
      })
    }
  </script>
</body>

</html>
